'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const credential_1 = require("./utils/credential");
const error_1 = require("./utils/error");
const catalyst_app_1 = require("./catalyst-app");
const validator_1 = require("./utils/validator");
const constants_1 = __importDefault(require("./utils/constants"));
const { INIT_TYPE, DEFAULT_APP_NAME, PROJECT_HEADER, CATALYST_ORIGIN, CATALYST_CONFIG_ENV_KEY } = constants_1.default;
class CatalystNamespace {
    constructor() {
        this.type = INIT_TYPE;
        this.credential = {
            refreshToken: (refreshTokenObj) => {
                return new credential_1.RefreshTokenCredential(refreshTokenObj);
            },
            accessToken: (access_token) => {
                return new credential_1.AccessTokenCredential({ access_token });
            },
            ticket: (ticket) => {
                return new credential_1.TicketCredential({ ticket });
            }
        };
        this.appCollection = {};
    }
    initializeApp(options, appName) {
        if (typeof appName === 'undefined') {
            appName = DEFAULT_APP_NAME;
        }
        if (appName in this.appCollection) {
            throw new error_1.CatalystAppError('duplicate_app', 'The app already exists.', appName);
        }
        if (!validator_1.isNonEmptyObject(options)) {
            options = this.loadOptionsFromEnvVar();
            if (!validator_1.isNonEmptyObject(options)) {
                throw new error_1.CatalystAppError('invalid_app_options', 'Options provided for initializeApp in invalid.', options);
            }
        }
        // credential alone can be not given
        if (typeof options.credential === 'undefined') {
            options.credential = new credential_1.ApplicationDefaultCredential();
        }
        try {
            validator_1.isNonEmptyStringOrNumber(options.project_id, 'project_id in options', true);
            validator_1.isNonEmptyStringOrNumber(options.project_key, 'project_key in options', true);
            validator_1.isNonEmptyStringOrNumber(options.environment, 'environment in options', true);
            validator_1.isNonEmptyString(appName, 'appName', true);
        }
        catch (e) {
            throw new error_1.CatalystAppError(e.code, e.message, e);
        }
        const app = new catalyst_app_1.CatalystApp(options);
        this.appCollection[appName] = app;
        return app;
    }
    initialize(object, type = 'auto') {
        let appOptions = {};
        switch (type) {
            case INIT_TYPE.advancedio:
                if (!object || typeof object.headers !== 'object') {
                    throw new error_1.CatalystAppError('invalid_app_object', 'the object passed to initialize method is not valid', object);
                }
                appOptions = this.loadOptionsFromObj(object['headers']);
                appOptions.credential = new credential_1.CatalystCredential(object['headers']);
                break;
            case INIT_TYPE.basicio:
                if (!object || typeof object.catalystHeaders !== 'object') {
                    throw new error_1.CatalystAppError('invalid_app_object', 'the object passed to initialize method is not valid', object);
                }
                appOptions = this.loadOptionsFromObj(object['catalystHeaders']);
                appOptions.credential = new credential_1.CatalystCredential(object['catalystHeaders']);
                break;
            default:
                if (object && typeof object.headers === 'object') {
                    return this.initialize(object, INIT_TYPE.advancedio);
                }
                if (object && typeof object.catalystHeaders === 'object') {
                    return this.initialize(object, INIT_TYPE.basicio);
                }
                throw new error_1.CatalystAppError('invalid_app_object', 'unable to find the type of initialisation. kindly specify one', object);
        }
        return new catalyst_app_1.CatalystApp(appOptions);
    }
    loadOptionsFromObj(obj) {
        const projectId = parseInt(obj[PROJECT_HEADER.id]);
        const projectKey = obj[PROJECT_HEADER.key];
        const environment = obj[PROJECT_HEADER.environment];
        const projectDomain = obj[PROJECT_HEADER.domain] || CATALYST_ORIGIN;
        if (!projectKey || !projectId) {
            throw new error_1.CatalystAppError('invalid_project_details', 'Failed to parse object', obj);
        }
        return {
            projectId,
            projectKey,
            environment,
            projectDomain
        };
    }
    loadOptionsFromEnvVar() {
        const config = process.env[CATALYST_CONFIG_ENV_KEY];
        if (!validator_1.isNonEmptyString(config)) {
            return {};
        }
        try {
            const contents = config.startsWith('{')
                ? config
                : fs_1.readFileSync(config, 'utf8');
            return JSON.parse(contents);
        }
        catch (err) {
            // Throw a nicely formed error message if the file contents cannot be parsed
            throw new error_1.CatalystAppError('invalid_app_options', 'Failed to parse app options : ' + err, err);
        }
    }
    app(appName) {
        if (typeof appName === 'undefined') {
            appName = DEFAULT_APP_NAME;
        }
        if (!validator_1.isNonEmptyString(appName)) {
            throw new error_1.CatalystAppError('invalid_app_name', 'Invalid app name provided. App name must be a non-empty string.', appName);
        }
        else if (!(appName in this.appCollection)) {
            let errorMessage = appName === DEFAULT_APP_NAME
                ? 'The default project does not exist. '
                : `project named "${appName}" does not exist. `;
            errorMessage += 'Make sure you call initializeApp() before getting the desired app';
            throw new error_1.CatalystAppError('no_app', errorMessage, appName);
        }
        return this.appCollection[appName];
    }
}
exports.default = CatalystNamespace;
